#####Данная реализация не гарантирует свободу от взаимной блокировки:
Приведем пример, для краткости обозначив t_c = thread\_count, 

				T1							T2
			  lock()
	  fetch_add == 0 (t_c = 1)			
			  поток в						lock()
	     критической секции		  fetch_add == 1 (t_c = 2)
		  
		  unlock(t_c == 1)
	  fetch_add == 1 (t_c = 2)
	(1): --------------------------------------------------
									fetch_sub (t_c = 1)
								  fetch_add == 1 (t_c = 2)
		fetch_sub (t_c = 1)
	  fetch_add == 1 (t_c = 2)
Блок действий после (1) может повторяться бесконечное число раз, следовательно, ни один из вызовов lock() не завершится -> это противоречит определению deadlock freedom.
		
							
#####Данная реализация гарантирует взаимное исключение:
Предположим противное: потоки A и B одновременно находятся в критической секции. Пусть A - первый попал в нее -> в момент вхождения в цикл thread\_count <= 0. При вхождении в цикл потоком B thread\_count <= 1 (но должно быть thread\_count <= 0). Следовательно, в момент вхождения в цикл потока A thread\_count <= -1. Такое значение счетчика получить невозможно (аналогично невозможности получения 1).
