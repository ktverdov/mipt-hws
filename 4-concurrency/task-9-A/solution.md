####A. Консенсус с помощью атомарной записи в 2 ячейки:
Считаем, что решаем бивалентную задачу (зачем отходить от традиций):

	arr = [-1, -1, -1] #используем по ячейке памяти для каждого потока и 
	одну общую в центре

	T decide(T value):
		winner #сюда запишем номер победившего потока
		id = get_thread_id() #номер потока
		proposed[id] = value

		multi-write(arr[id], value, arr[id + 1], value)
		
		if (arr[ (id + 1) % 3].load() == -1 || arr[1].load() != value):
			winner.store(id)  
			/* выйграли, если второй поток еще не пришел (в его ячейке -1)
				или записал свое значение в общую переменную после нас */
		else 
			winner.store(1 - id) #проиграли

		return proposed[winner.load()].load()

Получили алгоритм со всеми требуемыми свойствами:

- agreement
- validity
- Wait-Free