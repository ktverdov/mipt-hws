Считаем, что каждый поток исполняется на отдельном ядре процессора, у которого есть свой кэш данных.

2.
>Объясните, почему захват и освобождение спинлока промахиваются по кэшу лишь константное число раз.  


Промах по кэшу - ситуация при которой процессор не обнаружил требуемые ему данные в кэше, либо они оказались невалидными.

Acquire():
Изменения значения prev\_tail->next_, wait\_queue\_tail\_ могут вызвать два промаха по кэшу, т.к. эти данные в нем могут отсутствовать. Цикл по is\_owner\_.load() может вызвать максимум один промах, т.к. значение is\_owner\_ может измениться лишь один раз предыдущим потоком (если таковой будет), тем самым лишь один раз переведя данную кэш-линию в invalid-состояние.

Release():
Возможно 2 промаха по кэшу: wait\_queue\_tail\_ может быть invalid из-за изменений других потоков, next\_->is\_owner\_ не будет присутствовать в кэше. 

Таким образом, количество промахов по кэшу является константой.

>Почему он не подвержен проблемам cache ping-pong или thundering herd?

Спинлок не имеет разделяемых данных между всеми потоками, которые были бы подвержены быстрым (бесполезным; одновременным - для thundering herd) изменениям. wait\_queue\_tail\_ изменяется необходимое для поддержания списка | Acquire() + Release() | число раз. next\_ и is\_owner\_ разделяют только два потока -> нет проблемы thundering herd. Потоки инвалидируют эти значения единожды -> нет cache ping-pong.

3.
>Объясните, почему TAS, TATAS и Ticket спинлоки не гарантируют константного числа промахов по кэшу?

TAS: 
Каждый неудачный locked.exchange(true) в методе lock() инвалидирует кэш-линии, содержащие locked во всех других кэшах. Cоответственно, потоки, ожидающие в методе lock(), будут промахиваться по кэшу. Число промахов зависит от количества процессов -> не является константой.

TATAS:
locked.store(false) в методе unlock() инвалидирует копии locked во всех кэшах ждущих потоков. В следствие чего, каждый из них промахивается по кэшу, считывает locked и пытается сделать locked.exchange(true). Наиболее успешный поток изменяет значение и инвалидирует его в других кэшах. Число промахов зависит от количества процессов -> не гарантировано константное количество.

Ticket: 
Изменение потоком owner\_ticket в методе unlock() инвалидирует содержащие его кэш-линии во всех других кэшах. Т.к. остальные процессы, ждущие в методе lock(), непрерывно перечитывают эти данные, это вызывает промахи по кэшу, количество которых будет зависеть от числа потоков -> не гарантировано константное число
